TCP Related Documents Cheet Sheet

[フォーマット]
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[略語]
TCB    Transmission Control Block
RTT    Round Trip Time
SRTT   Smoothed RTT
RTO    Retransmission Timeout
SEQ    Sequence Number
ACK    Acknowledgement Number
UP     Urgent Pointer
WL     Last Window Update
MSS    Maximum Segment Size
SMSS   Sender MSS
RMSS   Receiver MSS
MTU    Maximum Transfer Unit
PMTUD  Path MTU Discovery
MSL    Maximum Segment Lifetime
ISN    Initial Sequence Number
ISS    Initial Send Sequence Number
IRS    Initial Receive Sequence Number
IW     Initial (Congestion) Window
RWND   Receive Window
CWND   Congestion Window
LFN    Long Fat Network
SWS    Silly Window Syndrome

[Maximum Segment Size]
 - RFC793
   - TCPオプション番号2で16bitのMSSをアナウンス可能
   - お互いSYNパケットにだけオプションを付ける
   - オプションが無ければセグメントサイズ無制限(仕様文面上は)
   - MSSオプションの値は送出I/FのMTU-40とするのが普通
   - MTUは通信メディアごとに大体決まっていてEthernetなら1500
   - つまりEthernet環境ではMSS=1500-40=1460となることが多い
 - RFC879
   - 当時「通信相手の環境について特段の知識が無い限りIPデータグラムは
     576bytes以内にすべし」という不文律があった
   - 576という数字の根拠は定かではないが、MLアーカイブなどからの断片
     情報によると、BBNで使われていたルータのIPデータグラム1つ分の内部
     バッファが576bytesの固定サイズだったことに由来しているらしい
   - TCP/IP headerを各々20bytesとしてTCP Payloadは536bytes以内
   - これがMSSオプション不在時の最大セグメントのデファクトとなった
   - 現実の実装では更に余裕を見てキリの良い512が採用されている
   - MSSオプションは自分の通信環境の知識を「アナウンス」する仕組み
   - 断じて「ネゴシエーション」の仕組みではない

[Path MTU Discovery]
 - RFC1191
   - 当時remote通信におけるPMTUはmin(576, local MSS)としていた
   - これでほとんどの場合必要以上に小さなパケットを使うハメになった
   - 動的にPMTUを見つける方法がPMTUD
   - TXはMTUをlocal MSSに初期化して全IPヘッダをDFフラグ付きで送る
   - 途中そのMSSで通過できないパスがあればRouterがICMPエラーを返す
   - TXはICMPエラーを検知したらMSSを適当に減らして同じことを繰り返す
   - ここでもしRouterがICMPエラーに問題のMTUを含めて通知できれば、
     TXは正確にMSSを何bytes減らせばいいかわかる
   - そのためICMPのToo Bigメッセージヘッダ仕様変更も提案
   - ICMPでのMTU通知が使えない場合のMSSの減らし方
     - 1度失敗したら576bytesにフォールバック
     - 毎回0.75などの定数倍で減らす
     - バイナリサーチなど高度なアルゴリズム
   - PMTUDは一見IPレイヤの機能のように見えるが、実際のところパケット
     サイズは最初にデータ分割する段階で確定するのでTCPの機能である
   - UDPなどアプリレイヤでデータ分割する場合、一般にパケットのバウン
     ダリを変更して再送するのは不可能なためPMTUDは使えない
   - UDPなどがTCPで発見したPMTU値にタダ乗りするのはOK
   - 単純にTCPレイヤに実装すると、異なるプロトコル間や複数TCP接続間で
     PMTUを共有できないため、得た情報はIPレイヤに保持すべき
   - PMTU情報は10分のオーダーでタイムアウトすること
   - PMTUDのICMPエラーは輻輳制御アルゴリズムのCWNDに影響しない
   - L4プロトコルによっては再送時にパケットサイズを変更できないが、
     その場合は既に構築済みのパケットにはIP断片化を許容して送り、次の
     パケットからサイズを適切に小さくする
 - RFC1981

[Initial Sequence Number]
 - RFC793
   - ISNの選択は単にランダムなだけではダメと明記
   - その目的は「直前のTCPの残骸と混ざらないようにする」こと
   - 4us毎にカウントアップする32bitクロックからISNを決定
   - 4.55時間で32bitを1周するので大丈夫だというのが当時の議論
   - この32bitクロックは容易に推測可能でセキュリティ上問題あり
 - RFC1323
   - TCP開始前に2*MSL以上待てばISN選択はどうでもいいとの指摘
 - RFC1948
   - 32bitクロック推測によるセキュリティ問題の軽減案
   - ISN = M + F(localip, localport, remoteip, remoteport)
   - MはRFC793のアルゴリズムと同じ32bitクロック
   - Fはハッシュ関数と秘密鍵による外部から推測不可能な要約関数
   - 何らかの契機で秘密鍵を更新する仕組みがあれば尚良い
   - MITM可能な攻撃者には無効な仕組みであることに注意
 - draft-ietf-tcpm-rfc1948bis
   - 上記RFCをInformationalからStandards Trackに昇格議論中

[Initial Congestion Window]
 - RFC793
   - 特段の規定無し
   - 初期の実装はRWND一杯まで使い切るものが多かった
 - RFC2001
   - 初めてIWは1*MSSと明記される
 - RFC2414
   - IW = min(4*MSS, max(2*MSS, 4380 bytes)) の式が初出
   - 4380は3*1460すなわち3*MSSのこと
   - 次のように言い換えられる
            MSS < 1095  IW = 4*MSS
     1095 < MSS < 2190  IW = 3*MSS
     2190 < MSS         IW = 2*MSS
 - draft-ietf-tcpm-initcwnd
   - IWを10*MSSにする提案が議論中

[Nagle Algorithm]
 - RFC896
   - 輻輳問題の多数の軽減策のうちのひとつ
   - ARPANETのIMP技術では輻輳問題は起こらなかった
   - ARPANETでは概してどのネットワークも帯域が一定で、IMPのキャパシ
     ティは過剰であり、スロットリング機能も備えていたため
   - 多様な帯域幅の外部NWと相互接続が始まると輻輳問題が顕著になった
   - 輻輳の原因のひとつに小さなパケットがある
   - John Nagleが提案した適応的解決策は以下の通り
     - ACK待ちSEGが残っている間は次のSEGを送らない
     - ただし一度のflush機会に複数SEGを同時送信するのはOK
     - RWNDが最大になるのを待って一気にデータ送信する戦略と言える
   - 対向ホストがDelayed ACKを採用した時の相性が悪い
   - かつて(1960年代)はタイマーによる解決策が採用されていた
     - 小さなSEGは200-500ms程度待ってから送るルール
     - ヤマが当たれば追加送信要求が来て1パケットにまとめられる
     - 例外として改行が含まれていれば即時送信する
     - この解決策はユーザーのinteractivityを犠牲にしている

[Delayed ACK]
 - RFC793
   - ACK送信は遅延すべきでないとの指摘
   - さもなければ無用な再送が発生するため
   - 輻輳に対する配慮として、小さなSEGに対してはRWNDを更新せずにACKを
     送り、その後バッファが十分大きくなった時点でACK+新RWNDを返すとい
     う戦略は許容するとの記述
 - RFC813
   - RFC793にはcorrectnessばかりでperformanceの規定が無いとの指摘
   - correctnessだけに配慮した実装による通信性能悪化をSWSと呼ぶ
   - SWSの解決策を2つ提示
   - 1つ目はRFC793にもあるRX側での小さなSEGに対するRWND更新の延期
     - この場合RWND更新頻度は減るがACKそのものは減らない
     - TX側の別解としてCWNDが一定割合以下ならSEGを送らない方式も
     - このTX側別解はNagle Algorithmと似ている
   - 2つ目の解がDelayed ACK
     - 以下の条件を満たせばすぐ次のSEGが来ると予想してACKを延期
       - PUSHフラグがセットされていない
       - すぐにでも通知すべきRWND更新情報が無い
     - この場合ACK個数とRWND更新頻度の両方が減る
     - 延期後アテが外れて次SEGが来なければ適切なタイマーでACKを返す
     - 当時の妥当なタイマーとして200-300msを推奨
     - しかし適応的なタイマー秒数選択が望ましいとの記述もあり
   - これらのアルゴリズムには2つの側面があることに注意
     - SEGサイズの細切れ化を防ぐことで輻輳を軽減する
     - 処理SEG数の減少によって両端のCPU使用率を削減する
 - RFC1122
   - ACK遅延秒数は最大0.5sまでにすべき
   - MSS一杯のストリーミングでは2SEGごとに最低1ACKを返すべき
   - Telnetなどの端末セッションでは、ACK遅延の挿入によって1SEGの中に
     ACK/RWND更新/文字Echoが相乗り可能になるとの実例を指摘
   - ACK遅延によってTX側のRTT評価が不正確になるとの指摘

[PSH Flag]
 - RFC793
   - PSHフラグはTX側アプリからRX側アプリへの即時SEG配送要求
   - PSH無しならTX側TCPは原則自由なタイミングでSEGを送出してよい
   - PSH要求とデータのSEG分割方法には何の関係もない
   - TX側アプリのPSH要求はデータを1SEGに詰め込むことを意味しない
   - TX側アプリのCLOSEコールは暗黙のPSH要求となる
   - RX側TCPに到達したFIN SEGは暗黙のPSH要求となる
   - 基本ひとまとまりのデータの最後の1SEGにPSHフラグを立てる
 - RFC1122
   - RX側TCPからアプリへのPSHフラグ存在通知は必須ではないことを明記
   - 実際UNIXのrecvfrom(),recvmsg()ではPSHフラグの有無を取得できない
   - 複数SEGで連続するPSHフラグは最後の1SEGにまとめるべき

[URG Flag]
 - RFC793
   - URGフラグの立ったSEGではUrgent Pointer(UP)フィールドが有効となる
   - UPは緊急データの最終SEQ+1(つまり通常データの先頭SEQ)を指す
   - UPはそのSEG自身の先頭SEQからの相対位置を指す
 - RFC1122
   - UPに関するRFC793の説明は間違いであるとの指摘
   - つまりUPは緊急データの最終SEQ+1ではなく最終SEQそのものを指す
   - UPまでのデータ長が無制限であることを明記
 - RFC6093
   - URGは相互運用性が無く有害なので非推奨とすることを宣言する文書
   - URGはRX側アプリに"urgent mode"に入る/出ることを指示するフラグ
   - よく誤解されることだがURGはOOBデータを指すのではない
     - IETF公式見解としてURGはインラインデータを意図している
     - ところがUNIXのRX側実装はそうなっていない
     - UPの最終byteはMSG_OOBフラグ付きでrecv()した場合のみ受け取れる
     - この動作はsetsockopt(SO_OOBINLINE)で無効化できる
   - 現実の実装におけるUPの解釈はRFC793に従っているという指摘
   - LinuxはRFC793/1122のUP解釈を切り替えるsysctlを持つが、これを使う
     と同じOS上においてさえ相互運用性がなくなるとの指摘
   - 現実の実装におけるUPのデータ長制限はバラバラだという指摘
   - 一時期URG処理のバグを狙った脆弱性がいくつか発見され、メジャーな
     FWがTCPのURGフラグとUPをクリアするようになった
   - このため現状のInternetはURGフラグを利用不可能な状態である
   - それでもURGを廃止するまでには至らないためガイドラインを示す:
     - OSは今後もURGをサポートすること
     - UPはRFC793を正しい解釈とすること
     - アプリはSO_OOBINLINEを必ず使用すること
     - 経路途中でFWがURGをクリアしても問題無いように設計すること

[Selective ACK]

[Zero Window Probing]
 - RFC793
   - RWND=0となった後にそこからの脱出を検知する仕組み
   - TXはRWND=0の時でも1byteの再送を繰り返す
   - RXはその1byteのSEGを受信出来ようと出来まいとACKする義務がある
   - この規則によりRX側でRWNDが回復したらTX側にも確実に伝わる
 - RFC1122
   - RFC793の明確化
   - TXはRWND=0になってからRTO経過後にZWPを開始する
   - その後のZWPインターバルは徐々に拡大するのが良い
 - draft-ietf-tcpm-persist
   - RFC1122に厳密に従うとDoS脆弱性となることを指摘
   - ZWPの規則よりローカルのリソース管理ポリシーが優越する
   - アプリケーションからZWP優越を明示された場合はその限りでない

[Keep Alive]
 - RFC793
   - Keep-Aliveについての言及は無い
 - RFC1122
   - 通信の途絶えたTCPでTXが定期的に生存確認をする仕組み
   - そうしなければリソースを占有し続けるTCPの回収が目的
   - TXが送信するSEGの中身は空データ推奨
   - 実装としては直前の1byteを含むSEGを送る場合もあった
   - RXが生きていればACKが返る
   - RXが死んでいればRSTが返る
   - 仕様と関係なく実装が普及してしまったことの言及
   - Keep-Aliveのデフォルトインターバルは2時間
   - Keep-AliveはOn-Off可能でデフォルトはOffとすること
   - 短所として帯域の浪費と無駄なTCP切断の可能性を指摘

[Slow Start]
[Congestion Avoidance]
[Fast Retransmit]
[Fast Recovery]
[Urgent Pointer]
