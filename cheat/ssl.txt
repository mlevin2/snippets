[Normal SSL Sequence]
ClientHello             ----->    
                                           ServerHello
                                           Certificate
                                     ServerKeyExchange
                                    CertificateRequest
                        <-----         ServerHelloDone
Certificate
ClientKeyExchange
CertificateVerify
ChangeCipherSpec
Finished                ----->    
                                      ChangeCipherSpec
                        <-----                Finished
Application Data        <---->        Application Data


[SSL Session Resume Sequence]
ClientHello(Session ID) ----->
                               ServerHello(Session ID)
                                      ChangeCipherSpec
                        <-----                Finished
ChangeCipherSpec
Finished                ----->
Application Data        <---->        Application Data


[Basic Syntax]
 - ASN.1やXDRに似ているがまったく別物の独自フォーマット
 - typedef構文: ExistingType NewType;
 - 数値はすべて最上位byteが先頭に来るByteStream
 - ただしAlignmentの制約が無いのでBigEndianとは違う
 - 組込基本型: opaque/uint8/16/24/32/64
 - 固定長列挙型: enum { foo(1), bar(2), baz(3) } TypeName;
   - 列挙型は取り得る最大値で暗黙に固定データ長が決まる
   - データ長を固定するためだけに無名の最大値を含める場合がある
       enum { foo(1), bar(2), baz(3), (65000) } TypeName;
     つまり上記の型は8bitではなく16bit長となる
 - 固定長配列型: uint8 uint40[5];
 - 可変長Vector型: uint16 IntVecType<40..800>;
   - 上記は16bit整数を要素とする40-800bytesのVector
   - 全長が40-800bytesであって要素数が40-800個なのではない
   - Vectorは可変長のためデータの前に長さをprependしてEncode
   - 長さField自身の長さは取り得る最大長によって決まる
   - つまり上記型のEncodeは<16bit len><40-800bytes data>となる
 - 複合型: structとselectがある
   - struct { Type1 t1; Type2 t2; } StructType;
   - select(FruitsType) {
       case apple: Red;
       case orange: Orange;
     } FruitsColor;
 - 暗号操作型: 決まった構造に展開されるマクロのようなもの
   - digitally-signed: デジタル署名
   - stream-ciphered: ストリーム暗号化
   - block-ciphered: ブロック暗号化
   - aead-ciphered: AEAD暗号化
   - public-key-encrypted: 公開鍵暗号化
   - 例: デジタル署名付きmessageの定義
     - digitally-signed struct {
         opaque message[message_len];
       } SignedMessage;


[Record Layer]
 - Type: レコード種別
   - 20: ChangeCipherSpec
   - 21: Alert
   - 22: Handshake
   - 23: ApplicationData
 - Major, Minor: SSLのバージョン番号
   - SSL2 => 2.0
   - SSL3 => 3.0
   - TLS1.0 => 3.1
   - TLS1.1 => 3.2
   - TLS1.2 => 3.3
 - Data: Typeによって様々なデータ
   - 交渉成立前は平文
   - 圧縮に合意していれば圧縮済みデータ
   - 暗号化に合意していれば暗号文とMAC
   - 暗号化データの形式はアルゴリズムの種別に依存する

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |     Major     |     Minor     |         Record
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 Length         |                     Data                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             ....                              |


[Handshake]
 - ClientHello: 受入可能オプションの提示
   - client_versionにサポートするTLSバージョンの最大値を提示
     - 特定バージョン未満の未サポートを通知する方法は無い
     - つまりSSL2は使いたくないと通知する方法は無い
     - TLSバージョンの非一致はC/S共にprotocol_version alertで通知
   - cipher_suitesに暗号アルゴリズムを希望順で提示
   - randomは文字通りランダムデータでreplay攻撃を防ぐ
 - ServerHello: ClientHelloで提示された中からオプションを選択
 - Certificate: SSL全体の信頼の源となるサーバ証明書
 - ClientKeyExchange: pre master secretの共有(RSAの場合)
   - pre master secretを元に双方が独立に共有鍵を計算
   - この計算手順をKDF: Key Derivation Functionという
   - pre master secret自身が共有秘密鍵となるのではない
   - 世の中のSSL3実装はRSA使用時のProtocol Formatを間違えている
     - Netscapeが仕込んだバグに業界が追随したため
 - Finished: Handshake自身の改竄を防ぐ

[KDF]
 - Key Derivation Function: 鍵導出関数
 - KDFにはHMACベースのPRF: Pseudo-Random Functionを使う
 - pre master secretからmaster secretを導出する
 - master secretをPRFに通して何種類かの鍵を生成する
 - PRF(secret, label, seed)は用途ごとにlabelを変えて使う
 - これにより1つのmaster secretから複数の鍵を導出できる
   - C=>S方向の暗号化・MAC・IV
   - S=>C方向の暗号化・MAC・IV
 - 以上はTLSにおけるKDFでSSL3の場合はまた別の手順になる
   - SSL3のKDFに脆弱性があるわけではない

[Diff between SSL2/3]
 - そもそもProtocolのFormatがSSL3以降と全然違う
 - CipherSpecの種類が少ない
   - 特にNULL暗号化が無いため改竄検知のみの通信が実現できない
 - MSがIEに実装した互換機能PCTの方が優れた性質を備えていた
   - Private Communications Technology
   - PCTの機能はSSL3の仕様に反映された
 - SSL2はclose_notify alertが無いため強制切断攻撃に弱い
   - 多くの場合L7レイヤで通信終了を通知するため問題にならない
 - RequestCertificate
   - Clientは証明書要求に対して提示するかエラーのどちらかのみ可能
   - 本当は回復可能なエラーなので証明書なしのまま継続しても良いはず
 - Certificate
   - 構文上ひとつの証明書しか送ることができない
   - つまり中間証明書とサーバ証明書を同時に送ることができない

[Diff between SSL3/TLS]
 - SSL3には仕様と世の中の実装の食い違いが多数ある
   - 歴史的経緯によりNetscapeの実装が事実上の仕様となっている
 - MACの方式: TLSはHMAC/SSLv3はprecursor
 - alert codeが大幅に追加された
 - TLSではFortezzaのサポート要件が無くなった
   - FortezzaとはNSAが定めるSecurity Algorithmの集合
 - TLSはクライアント証明書の種類が減った
 - CertificateVerifyの署名対象データの構成が変わった
 - KDFつまりmaster secretの計算方法が変わった
 - FinishedのDigest計算方法が変わった
 - paddingの条件が緩くなった
 - TLS1からSSL3へのFallbackが定義された


